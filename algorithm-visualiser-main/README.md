# Path Visualizer

A collaborative web development project for visualising multiple algorithms.

## Algorithms

### Graph Algorithms

**Breadth First Search (BFS)** is a graph traversal algorithm that explores all the vertices in a graph at the current depth before moving on to the vertices at the next depth level. It starts at a specified vertex and visits all its neighbors before moving on to the next level of neighbors. BFS is commonly used in algorithms for pathfinding, connected components, and shortest path problems in graphs.

**Breadth First Search (BFS)** is an algorithm for traversing or searching graph data structures. It starts at a given node and explores as far as possible along each branch before backtracking, ensuring all nodes are visited.

**Dijkstra's Algorithm** finds the shortest paths from a source node to all other nodes in a weighted graph. It uses a priority queue to repeatedly select the node with the smallest known distance, updating distances to its neighbors if shorter paths are found, until all nodes are processed.


### Sorting Algorithms

**Bubble Sort** is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This process is repeated until the list is sorted. The algorithm gets its name because smaller elements "bubble" to the top of the list through repeated swaps.

**Insertion Sort** is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It iterates through an input array and, for each element, it finds the correct position in the sorted array and inserts the element there. This process is repeated until the entire array is sorted. 

**Selection Sort** is a straightforward sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist. Initially, the sorted sublist is empty, and the unsorted sublist contains all elements. The algorithm repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted sublist and moves it to the end of the sorted sublist.

**Merge Sort** is a divide-and-conquer algorithm for sorting arrays. It divides the input array into two halves, recursively sorts each half, and then merges the sorted halves to produce a single sorted array. The merging step involves comparing elements from the two halves and placing them in the correct order. This process continues until the entire array is sorted.

**Quick Sort** is a highly efficient sorting algorithm based on the divide-and-conquer principle. It works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then recursively sorted.
